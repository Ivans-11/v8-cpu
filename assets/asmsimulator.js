var app = angular.module('ASMSimulator', []);
;app.service('uploader', ['opcodes', function (opcodes) {
    return {
        go: function (input) {
            // Contains the program code & data generated by the assembler
            var code = [];
            // Contains data on disk
            var disk = [];
            // Contains the mapping from instructions to assembler line
            var mapping = {};
            // Hash map of label used to replace the labels after the assembler generated the code
            var labels = {};
            // Split text into code lines
            var lines = input.split('\n');
            for (var i = 0, l = lines.length; i < l; i++) {
                var line = lines[i];
                var end_of_line = line.indexOf(';');
                if (end_of_line > 0)
                    line = line.slice(0, end_of_line - 1);
                else if (end_of_line === 0)
                    line = '';
                var codes = line.split(' ');
                for (var j = 0, codenum = codes.length; j < codenum; j++) {
                    if (codes[j] === '')
                        continue;
                    for (var k = 1; k < codes[j].length; k += 2) {
                        var codevalue = parseInt(codes[j].slice(k - 1, k + 1), 16);
                        if (codevalue < 0 || codevalue > 255) {
                            throw {error: "code must be a value between 0...255"};
                        }
                        code.push(codevalue);
                    }
                }
            }
            return {code: code, disk: disk, mapping: mapping, labels: labels};
        }
    };
}]);

app.service('assembler', ['opcodes', function (opcodes) {
    return {
        go: function (input) {
            // Use https://www.debuggex.com/
            // Matches: "label: INSTRUCTION OPERAND1, OPERAND2, OPERAND3
            // GROUPS:     1         3         4         7         10
            var regex = /^[\t ]*(?:([.A-Za-z]\w*)(@\w+)?[:])?(?:[\t ]*([A-Za-z]{2,6})(?:[\t ]+([-.A-Za-z0-9]\w*((\+|-)\d+)?)(?:[\t ]*[,][\t ]*([-.A-Za-z0-9]\w*((\+|-)\d+)?)(?:[\t ]*[,][\t ]*([-.A-Za-z0-9]\w*((\+|-)\d+)?))?)?)?)?/;
                //^[\t ]*(?:([.A-Za-z]\w*)(@\w+)?[:])?  -- label: or nothing
                //(?:[\t ]*([A-Za-z]{2,6})              -- instruction
                //([.A-Za-z0-9]\w*((\+|-)\d+)?)         -- (OPERAND1)
            // Regex group indexes for operands
            var op1_group = 4;
            var op2_group = 7;
            var op3_group = 10;
            // MATCHES: "(+|-)INTEGER"
            var regexNum = /^[-+]?[0-9]+$/;
            // MATCHES: "(.L)abel"
            var regexLabel = /^([.A-Za-z_]\w*)((\+|-)\d+)?$/;
            // Contains the program code & data generated by the assembler
            var memory = [];
            // Contains data on disk
            var disk = [];
            // The address where the next instruction/data will be placed at
            var current = 0;
            // Contains the mapping from instructions to assembler line
            var mapping = {};
            // Hash map of label used to replace the labels after the assembler generated the code
            var labels = {};
            // Hash of uppercase labels used to detect duplicates
            var normalizedLabels = {};

            var diskpart = false;

            // Split text into code lines
            var lines = input.split('\n');

            // Allowed formats: 200, 200d, 0xA4, 0o48, 101b
            var parseNumber = function (input) {
                if (input.slice(0, 2) === "0x") {
                    return parseInt(input.slice(2), 16);
                } else if (regexNum.exec(input)) {
                    return parseInt(input, 10) & 0xFF;
                } else {
                    return undefined;
                }
            };

            // Allowed registers: R0 - RF
            var parseRegister = function (input) {
                input = input.toUpperCase();
                if (input === 'R0') {
                    return 0;
                } else if (input === 'R1') {
                    return 1;
                } else if (input === 'R2') {
                    return 2;
                } else if (input === 'R3') {
                    return 3;
                } else if (input === 'R4') {
                    return 4;
                } else if (input === 'R5') {
                    return 5;
                } else if (input === 'R6') {
                    return 6;
                } else if (input === 'R7') {
                    return 7;
                } else if (input === 'R8') {
                    return 8;
                } else if (input === 'R9') {
                    return 9;
                } else if (input === 'RA') {
                    return 10;
                } else if (input === 'RB') {
                    return 11;
                } else if (input === 'RC') {
                    return 12;
                } else if (input === 'RD') {
                    return 13;
                } else if (input === 'RE') {
                    return 14;
                } else if (input === 'RF') {
                    return 15;
                } else {
                    return undefined;
                }
            };

            var parseAddress = function (input) {
                var number = parseNumber(input);
                if (number !== undefined) {
                    if (number >= 0 && number <= 255)
                        return number;
                    throw "addresses must have a value between 0-255";
                }

                var match = regexLabel.exec(input);
                if (match[1] === undefined)
                    return undefined;
                var offset = 0;
                if (match[2] !== undefined) {
                    var sign = match[2][0] === '-' ? -1 : 1;
                    offset = sign * parseInt(match[2].slice(1), 10);
                }
                return {label: match[1], offset: offset};
            };

            var addLabel = function (label, address) {
                var upperLabel = label.toUpperCase();
                if (upperLabel in normalizedLabels)
                    throw "Duplicate label: " + label;

                if (address === undefined) {
                    labels[label] = current;
                } else if (address >= 0 && address <= 255) {
                    labels[label] = address;
                    current = address;
                    while (memory.length < current)
                        memory.push(0);
                } else {
                    throw "addresses must have a value between 0-255";
                }
            };

            var checkNoExtraArg = function (instr, arg) {
                if (arg !== undefined) {
                    throw instr + ": too many arguments";
                }
            };

            var generate = function () {
                for (var arg in arguments) {
                    var datum = arguments[arg];
                    if (current < 0 || current > 255)
                        throw "Too many code/data";
                    if (current == memory.length)
                        memory.push(datum);
                    else if (current < memory.length)
                        memory[current] = datum;
                    current += 1;
                }
            };

            for (var i = 0, l = lines.length; i < l; i++) {
                var line = lines[i].trim();

                // Comments are not parsed
                if (line === "" || line.slice(0, 1) == ";")
                    continue;

                // Fastpath: if the line contains data in disk, simply parse them as a sequence of hex numbers
                if (diskpart) {
                    var bytes = line.split(' ');
                    for (var j = 0, codenum = bytes.length; j < codenum; j++) {
                        if (bytes[j] === '')
                            continue;
                        disk.push(parseInt(bytes[j], 16) % 256);
                    }
                    continue;
                } else if (line === "==========") {
                    diskpart = true;
                    continue;
                }

                try {
                    var match = regex.exec(lines[i]);
                    if (match[1] !== undefined || match[3] !== undefined) {
                        if (match[1] !== undefined) {
                            // TODO: Support hardcoded addresses
                            var address = match[2];
                            if (address !== undefined)
                                address = parseNumber(address.slice(1));
                            addLabel(match[1], address);
                        }

                        if (match[3] !== undefined) {
                            var instr = match[3].toUpperCase();
                            var p1, p2, p3, opCode;

                            // Add mapping instr pos to line number
                            // Don't do it for DB as this is not a real instruction
                            if (instr !== 'DB') {
                                mapping[current] = i;
                            }

                            switch (instr) {
                            case 'DB':
                                p1 = parseNumber(match[op1_group]);
                                if (p1 !== undefined)
                                    generate(p1 & 0xFF);
                                else
                                    throw "DB does not support this operand";
                                break;
                            case 'HALT':
                                checkNoExtraArg('HALT', match[op1_group]);
                                checkNoExtraArg('HALT', match[op2_group]);
                                checkNoExtraArg('HALT', match[op3_group]);
                                generate(opcodes.HALT << 4, 0);
                                break;
                            case 'MOVE':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                checkNoExtraArg('MOVE', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.MOVE << 4, (p2 << 4) | p1);
                                else
                                    throw "MOVE does not support this operands";
                                break;
                            case 'ADDI':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                p3 = parseRegister(match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined && p3 !== undefined)
                                    generate(opcodes.ADD_INT << 4 | p1, (p2 << 4) | p3);
                                else
                                    throw "ADDI does not support this operands";
                                break;
                            case 'ADDF':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                p3 = parseRegister(match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined && p3 !== undefined)
                                    generate(opcodes.ADD_FLOAT << 4 | p1, (p2 << 4) | p3);
                                else
                                    throw "ADDF does not support this operands";
                                break;
                            case 'LOADM':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseAddress(match[op2_group]);
                                checkNoExtraArg('LOADM', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.LOAD_FROM_MEMORY << 4 | p1, p2);
                                else
                                    throw "LOADM does not support this operands";
                                break;
                            case 'LOADB':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseAddress(match[op2_group]);
                                checkNoExtraArg('LOADB', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.LOAD_WITH_CONSTANT << 4 | p1, p2);
                                else
                                    throw "LOADB does not support this operands";
                                break;
                            case 'LOADP':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                checkNoExtraArg('LOADP', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.LOAD_FROM_POINTER << 4 | p1, p2);
                                else
                                    throw "LOADP does not support this operands";
                                break;
                            case 'STOREM':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseAddress(match[op2_group]);
                                checkNoExtraArg('STOREM', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.STORE_TO_MEMORY << 4 | p1, p2);
                                else
                                    throw "STOREM does not support this operands";
                                break;
                            case 'STOREP':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                checkNoExtraArg('STOREP', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.STORE_TO_POINTER << 4 | p1, p2);
                                else
                                    throw "STOREP does not support this operands";
                                break;
                            case 'JUMP':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseAddress(match[op2_group]);
                                checkNoExtraArg('JUMP', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.JUMP_IF_EQUAL << 4 | p1, p2);
                                else
                                    throw "JUMP does not support this operands";
                                break;
                            case 'JUMPL':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseAddress(match[op2_group]);
                                checkNoExtraArg('JUMPL', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.JUMP_IF_LESS << 4 | p1, p2);
                                else
                                    throw "JUMPL does not support this operands";
                                break;
                            case 'AND':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                p3 = parseRegister(match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined && p3 !== undefined)
                                    generate(opcodes.AND << 4 | p1, (p2 << 4) | p3);
                                else
                                    throw "AND does not support this operands";
                                break;
                            case 'OR':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                p3 = parseRegister(match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined && p3 !== undefined)
                                    generate(opcodes.OR << 4 | p1, (p2 << 4) | p3);
                                else
                                    throw "OR does not support this operands";
                                break;
                            case 'XOR':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseRegister(match[op2_group]);
                                p3 = parseRegister(match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined && p3 !== undefined)
                                    generate(opcodes.XOR << 4 | p1, (p2 << 4) | p3);
                                else
                                    throw "XOR does not support this operands";
                                break;
                            case 'ROT':
                                p1 = parseRegister(match[op1_group]);
                                p2 = parseNumber(match[op2_group]);
                                checkNoExtraArg('ROT', match[op3_group]);
                                if (p1 !== undefined && p2 !== undefined)
                                    generate(opcodes.ROTATE << 4 | p1, p2);
                                else
                                    throw "LOADB does not support this operands";
                                break;
                            default:
                                throw "Invalid instruction: " + match[2];
                            }
                        }
                    } else {
                        throw "Syntax error";
                    }
                } catch (e) {
                    throw {error: e, line: i};
                }
            }

            // Replace label
            for (i = 0, l = memory.length; i < l; i++) {
                if (!angular.isNumber(memory[i])) {
                    var pair = memory[i];
                    if (pair.label in labels) {
                        memory[i] = (labels[pair.label] + pair.offset) & 0xFF;
                    } else {
                        throw {error: "Undefined label: " + pair.label};
                    }
                }
            }

            return {code: memory, disk: disk, mapping: mapping, labels: labels};
        }
    };
}]);

/*
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
;function log(msg) {
    setTimeout(function() {
        throw new Error(msg);
    }, 0);
}

app.service('cpu', ['opcodes', 'memory', function(opcodes, memory) {
    var cpu = {
        step: function() {
            var self = this;

            var byteToNumber = function(val) {
                if (val < 128) {
                    return val;
                } else {
                    return val - 255;
                }
            };

            var readReg = function(id) {
                return self.gpr[id];
            };

            var writeReg = function(id, val) {
                self.gpr[id] = val;
                if (id == 15) {
                    self.updateTimer = true;
                    if (val > 0) {
                        self.countdown = val;
                    } else {
                        self.countdown = 0;
                    }
                }
            };

            var findHighestBit = function(bits, max) {
                var i;
                for (i = max; i >= 0; i--) {
                    if ((bits >> i) !== 0)
                        break;
                }
                return i;
            };

            var floatingAdd = function(a, b) {
                var a_sign = (a & 0x80) >> 7, a_expo = ((a & 0x70) >> 4), a_mant = a & 0x0F;
                var b_sign = (b & 0x80) >> 7, b_expo = ((b & 0x70) >> 4), b_mant = b & 0x0F;
                var a_fix = (a_mant << a_expo), b_fix = (b_mant << b_expo);
                var result_sign, result_fix;
                if (a_sign == b_sign) {
                    result_sign = a_sign;
                    result_fix = a_fix + b_fix;
                } else {
                    if (a_fix > b_fix) {
                        result_sign = a_sign;
                        result_fix = a_fix - b_fix;
                    } else if (a_fix < b_fix) {
                        result_sign = b_sign;
                        result_fix = b_fix - a_fix;
                    } else {
                        result_fix = 0;
                        result_sign = 0;
                    }
                }
                var result_expo = findHighestBit(result_fix, 16) - 3;
                if (result_expo > 7) {
                    result_expo = 7;
                } else if (result_expo < 0) {
                    result_expo = 0;
                }
                var result_mant = (result_fix >> result_expo) & 0xF;
                var result = (result_sign << 7) | (result_expo << 4) | result_mant;
                return result;
            };

            var updateIR = function(instr) {
                self.ir = '';
                if (instr[0] <= 15)
                    self.ir += '0' + instr[0].toString(16);
                else
                    self.ir += instr[0].toString(16);
                if (instr[1] <= 15)
                    self.ir += '0' + instr[1].toString(16);
                else
                    self.ir += instr[1].toString(16);
            };

            self.updateTimer = false;
            self.status = '';

            var instr = [memory.load(self.ip), memory.load(self.ip + 1)];
            var opcode = instr[0] >> 4;
            var regDest = instr[0] & 0x0F, regSource1 = instr[1] >> 4, regSource2 = instr[1] & 0x0F;
            var mem = instr[1], num = instr[1];
            updateIR(instr);
            self.ip = (self.ip + 2) & 0xFF;
            switch(opcode) {
            case opcodes.LOAD_FROM_MEMORY:
                writeReg(regDest, memory.load(mem));
                break;
            case opcodes.LOAD_WITH_CONSTANT:
                writeReg(regDest, num);
                break;
            case opcodes.STORE_TO_MEMORY:
                memory.store(mem, readReg(regDest));
                break;
            case opcodes.MOVE:
                writeReg(regSource2, readReg(regSource1));
                break;
            case opcodes.ADD_INT:
                writeReg(regDest, (readReg(regSource1) + readReg(regSource2)) & 0xFF);
                break;
            case opcodes.ADD_FLOAT:
                writeReg(regDest, floatingAdd(readReg(regSource1), readReg(regSource2)));
                break;
            case opcodes.OR:
                writeReg(regDest, readReg(regSource1) | readReg(regSource2));
                break;
            case opcodes.AND:
                writeReg(regDest, readReg(regSource1) & readReg(regSource2));
                break;
            case opcodes.XOR:
                writeReg(regDest, readReg(regSource1) ^ readReg(regSource2));
                break;
            case opcodes.ROTATE:
                var delta = num % 8, val = readReg(regDest);
                writeReg(regDest, (val >> delta) + ((val & ((1 << delta) - 1)) << (8 - delta)));
                break;
            case opcodes.JUMP_IF_EQUAL:
                if (readReg(regDest) == readReg(0)) {
                    self.ip = mem;
                }
                break;
            case opcodes.HALT:
                self.ip = (self.ip - 2) & 0xFF;
                return false;
            case opcodes.LOAD_FROM_POINTER:
                writeReg(regDest, memory.load(readReg(regSource2)));
                break;
            case opcodes.STORE_TO_POINTER:
                memory.store(readReg(regSource2), readReg(regDest));
                break;
            case opcodes.JUMP_IF_LESS:
                if (byteToNumber(readReg(regDest)) < byteToNumber(readReg(0))) {
                    self.ip = mem;
                }
                break;
            }

            if (self.countdown > 0 && !self.updateTimer) {
                self.countdown -= 1;
                if (self.countdown === 0) {
                    memory.store(0xFD, self.ip);
                    self.ip = 0x80;
                    self.countdown = readReg(15);
                    self.status = '(Interrupted!)';
                }
            }

            return true;
        },
        reset: function() {
            var self = this;

            self.gpr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
            self.ip = 0;
            self.ir = '0000';
            self.status = '';

            self.countdown = 0;
            self.updateTimer = false;
        }
    };

    cpu.reset();
    return cpu;
}]);

/*
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
;app.service('memory', ['printer', function (printer) {
    var memory = {
        data: Array(256),
        lastAccess: -1,
        diskdata: Array(256),
        statusnow: 0,
        sector_address: 0,
        memory_address: 0,
        disk_operation: 0,
        disk_latency: 0,
        sectorlength: 16,

        load: function (address) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "Memory access violation at " + address;
            }

            self.lastAccess = address;

            if (address == 0xFE) {
                return printer.load();
            } else if (address == 0xFF) {
                if (self.disk_latency > 0) {
                    self.disk_latency = self.disk_latency - 1;
                    return 0;
                }
                if (self.disk_operation === 0x00) {
                    for(var i = 0; i < self.sectorlength; i++)
                        self.data[self.memory_address + i] = self.diskdata[self.sector_address * self.sectorlength + i];
                } else if (self.disk_operation === 0x01) {
                    for(var j = 0; j < self.sectorlength; j++)
                        self.diskdata[self.sector_address * self.sectorlength + j] = self.data[self.memory_address + j];
                }
                self.statusnow = 0;
                self.sector_address = 0;
                self.memory_address = 0;
                return 0xFF;
            }
            return self.data[address];
        },
        store: function (address, value) {
            var self = this;

            if (address < 0 || address >= self.data.length) {
                throw "Memory access violation at " + address;
            }

            self.lastAccess = address;

            if (address == 0xFE) {
                return printer.store(value);
            }
            if (address == 0xFF)
            {
                if (self.statusnow === 0)
                {
                    self.statusnow = 1;
                    self.sector_address = value;
                } else if (self.statusnow === 1) {
                    self.statusnow = 2;
                    self.memory_address = value;
                } else if(self.statusnow === 2) {
                    self.disk_operation = value;
                    self.disk_latency = 3;
                }
                return;
            }
            self.data[address] = value;
        },
        reset: function () {
            var self = this;

            self.lastAccess = -1;
            self.statusnow = 0;
            self.sector_address = 0;
            self.memory_address = 0;
            self.disk_operation = 0;
            self.disk_latency = 0;
            for (var i = 0, l = self.data.length; i < l; i++) {
                self.data[i] = 0;
            }
            for(i = 0;i < self.diskdata.length;i++)
            {
                self.diskdata[i] = 0;
            }
        }
    };

    memory.reset();
    return memory;
}]);

/*
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
;app.service('opcodes', [function() {
    var opcodes = {
        NONE: 0,
        LOAD_FROM_MEMORY: 1,
        LOAD_WITH_CONSTANT: 2,
        STORE_TO_MEMORY: 3,
        MOVE: 4,
        ADD_INT: 5,
        ADD_FLOAT: 6,
        OR: 7,
        AND: 8,
        XOR: 9,
        ROTATE: 10,
        JUMP_IF_EQUAL: 11,
        HALT: 12,
        LOAD_FROM_POINTER: 13,
        STORE_TO_POINTER: 14,
        JUMP_IF_LESS: 15
    };

    return opcodes;
}]);

/*
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
;app.service('printer', [function () {
    var printer = {
        data: '',
        load: function() {
            return 0;
        },
        store: function(value) {
            var self = this;
            if (value < 16)
                self.data += '0' + value.toString(16).toUpperCase() + " ";
            else
                self.data += value.toString(16).toUpperCase() + " ";
        },
        reset: function () {
            var self = this;
            self.data = '';
        }
    };

    printer.reset();
    return printer;
}]);

/*
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
;app.controller('Ctrl', ['$document', '$scope', '$timeout', '$http', 'cpu', 'memory', 'printer', 'assembler', 'uploader', function ($document, $scope, $timeout, $http, cpu, memory, printer, assembler, uploader) {
    $scope.printer = printer;
    $scope.memory = memory;
    $scope.cpu = cpu;
    $scope.error = '';
    $scope.isRunning = false;
    $scope.displayHex = true;
    $scope.displayInstr = true;
    $scope.displayA = false;
    $scope.displayB = false;
    $scope.displayC = false;
    $scope.displayD = false;
    $scope.speeds = [{speed: 1, desc: "1 HZ"},
                     {speed: 4, desc: "4 HZ"},
                     {speed: 8, desc: "8 HZ"},
                     {speed: 16, desc: "16 HZ"}];
    $scope.speed = 4;
    $scope.example = '';
    $scope.examples = [];

    $scope.code = ";; Choose an example above or write your own code here :)";
    $scope.reset = function () {
        cpu.reset();
        memory.reset();
        printer.reset();
        $scope.error = '';
        $scope.selectedLine = -1;
        $scope.mapping = undefined;
    };

    $scope.executeStep = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }

        try {
            // Execute
            var res = cpu.step();

            // Mark in code
            if (cpu.ip in $scope.mapping) {
                $scope.selectedLine = $scope.mapping[cpu.ip];
            }

            return res;
        } catch (e) {
            $scope.error = e;
            return false;
        }
    };

    var runner;
    $scope.run = function () {
        if (!$scope.checkPrgrmLoaded()) {
            $scope.assemble();
        }

        $scope.isRunning = true;
        runner = $timeout(function () {
            if ($scope.executeStep() === true) {
                $scope.run();
            } else {
                $scope.isRunning = false;
            }
        }, 1000 / $scope.speed);
    };

    $scope.stop = function () {
        $timeout.cancel(runner);
        $scope.isRunning = false;
    };

    $scope.checkPrgrmLoaded = function () {
        for (var i = 0, l = memory.data.length; i < l; i++) {
            if (memory.data[i] !== 0) {
                return true;
            }
        }

        return false;
    };

    $scope.getChar = function (value) {
        var text = String.fromCharCode(value);

        if (text.trim() === '') {
            return '\u00A0\u00A0';
        } else {
            return text;
        }
    };

    $scope.assemble = function () {
        try {
            $scope.reset();

            var assembly = assembler.go($scope.code);
            $scope.mapping = assembly.mapping;
            var binary = assembly.code;
            var disk = assembly.disk;
            $scope.labels = assembly.labels;

            if (binary.length > memory.data.length)
                throw {error: "Binary code does not fit into the memory. Max " + memory.data.length + " bytes are allowed"};

            if (disk.length > memory.diskdata.length)
                throw {error: "Disk data does not fit into the disk. Max " + memory.diskdata.length + " bytes are allowed"};

            for (var i = 0, l = binary.length; i < l; i++) {
                memory.data[i] = binary[i];
            }

            for (i = 0, l = disk.length; i < l; i++) {
                memory.diskdata[i] = disk[i];
            }

            if ($scope.labels['.entry'] !== undefined) {
                cpu.ip = $scope.labels['.entry'];
            }
        } catch (e) {
            if (e.line !== undefined) {
                $scope.error = e.line + " | " + e.error;
                $scope.selectedLine = e.line;
            } else {
                $scope.error = e.error;
            }
        }
    };

    $scope.upload = function () {
        try {
            $scope.reset();

            var binarycode = uploader.go($scope.code);
            $scope.mapping = binarycode.mapping;
            var binary = binarycode.code;
            $scope.labels = binarycode.labels;

            if (binary.length > memory.data.length)
                throw "Binary code does not fit into the memory. Max " + memory.data.length + " bytes are allowed";

            for (var i = 0, l = binary.length; i < l; i++) {
                memory.data[i] = binary[i];
            }
        } catch (e) {
            if (e.line !== undefined) {
                $scope.error = e.line + " | " + e.error;
                $scope.selectedLine = e.line;
            } else {
                $scope.error = e.error;
            }
        }
    };

    $scope.compile = function () {
        $http.post('/', {"source": $scope.code}).success(function(response){
        $scope.code = response; $scope.assemble();});
    };

    $scope.initExamples = function() {
        $http.get('examples/examples.json').then(function(response) {
            var filelist = response.data;
            for (var i = 0; i < filelist.length; i++) {
                var contents = filelist[i].split('|');
                var filename = contents[0], desc = contents[1];
                $scope.examples.push({id: filename, desc: desc});
            }
        }, function(error) {
            console.error("Failed to load examples.json", error);
        });
    };

    $scope.showExample = function(key) {
        var response = $http.get('examples/' + $scope.example);

        response.success(function(data, status, headers, config) {
            $scope.code = data;
        });
        response.error(function(data, status, headers, config) {
            console.error("ajax failed");
        });
    };

    $scope.jumpToLine = function (index) {
        $document[0].getElementById('sourceCode').scrollIntoView();
        $scope.selectedLine = $scope.mapping[index];
    };


    $scope.isInstruction = function (index) {
        return $scope.mapping !== undefined &&
            $scope.mapping[index] !== undefined &&
            $scope.displayInstr;
    };

    $scope.getMemoryCellCss = function (index) {
        if ($scope.isInstruction(index)) {
            return 'instr-bg';
        } else {
            return '';
        }
    };

    $scope.getMemoryInnerCellCss = function (index) {
        if (index === cpu.ip) {
            return 'marker marker-ip';
        } else if (index === cpu.sp) {
            return 'marker marker-sp';
        } else if (index === cpu.gpr[0] && $scope.displayA) {
            return 'marker marker-a';
        } else if (index === cpu.gpr[1] && $scope.displayB) {
            return 'marker marker-b';
        } else if (index === cpu.gpr[2] && $scope.displayC) {
            return 'marker marker-c';
        } else if (index === cpu.gpr[3] && $scope.displayD) {
            return 'marker marker-d';
        } else {
            return '';
        }
    };
}]);

/*
 * Local variables:
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
;app.filter('flag', function() {
    return function(input) {
        return input.toString().toUpperCase();
    };
});
;app.filter('number', function() {
    return function(input, isHex) {
	if (input === 0 || input === undefined)
            return "00";
        if (isHex) {
            var hex = input.toString(16).toUpperCase();
            return hex.length == 1 ? "0" + hex: hex;
        } else {
            return input.toString(10);
        }
    };
});
;// Source: http://lostsource.com/2012/11/30/selecting-textarea-line.html
app.directive('selectLine', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            scope.$watch('selectedLine', function () {
                if (scope.selectedLine >= 0) {
                    var lines = element[0].value.split("\n");

                    // Calculate start/end
                    var startPos = 0;
                    for (var x = 0; x < lines.length; x++) {
                        if (x == scope.selectedLine) {
                            break;
                        }
                        startPos += (lines[x].length + 1);
                    }

                    var endPos = lines[scope.selectedLine].length + startPos;

                    // Chrome / Firefox
                    if (typeof(element[0].selectionStart) != "undefined") {
                        element[0].focus();
                        element[0].selectionStart = startPos;
                        element[0].selectionEnd = endPos;
                    }

                    // IE
                    if (document.selection && document.selection.createRange) {
                        element[0].focus();
                        element[0].select();
                        var range = document.selection.createRange();
                        range.collapse(true);
                        range.moveEnd("character", endPos);
                        range.moveStart("character", startPos);
                        range.select();
                    }
                }
            });
        }
    };
}]);
;app.filter('startFrom', function() {
    return function(input, start) {
        start = +start; //parse to int
        return input.slice(start);
    };
});
;app.directive('tabSupport', [function () {
    return {
        restrict: 'A',
        link: function (scope, element, attrs, controller) {
            element.bind("keydown", function (e) {
                if (e.keyCode === 9) {
                    var val = this.value;
                    var start = this.selectionStart;
                    var end = this.selectionEnd;

                    this.value = val.substring(0, start) + '\t' + val.substring(end);
                    this.selectionStart = this.selectionEnd = start + 1;

                    e.preventDefault();
                    return false;
                }
            });
        }
    };
}]);
